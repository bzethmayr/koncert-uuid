/**
 * 3:06, returning
 *
 * <pre>
 * You are being asked to simulate a UUID generator by creating sequences of numbers, written out as strings.
 * </pre>
 * <ul>
 *     <li>Weakest form: The output is a string</li>
 *     <li>Surprising implication: The output is not to be hexadecimal?
 *     However, a hexadecimal number is still a number.</li>
 *     <li>Not explicit: Shall this confirm in any way to the UUID standard?</li>
 * </ul>
 * <pre>
 * If the resulting string is under 30 characters long, it should be padded,
 * </pre>
 * <ul>
 *     <li>Details of padding are not stated. Anything from 0s to a prefix from another run would satisfy this.</li>
 * </ul>
 * <pre>
 * if it’s over 40 characters long – then it should be truncated.
 * </pre>
 * <ul><li>ok</li></ul>
 *
 * <ul>
 *     <li>A couple things from this: We are not generating anything like standard UUIDs</li>
 *     <li>We need to be working in a type capable of 40 decimal digits. Maybe BigInteger not long</li>
 * </ul>
 * <pre>
 *
 *
 * Please create a REST Spring Boot API endpoint that implements a function that generates these simulated sequences.
 * </pre>
 * <ul>
 *     <li>I am gonna pretend you said "exposes a function"</li>
 * </ul>
 * <pre>
 * Possible parameters of x,y,z maybe be set with request.
 *
 *
 *
 * Use this rule for generating number sequences:
 *
 * 1.     Start with a randomly generated (real) number as the base.
 * </pre>
 * <ul>
 *     <li>So, SecureRandom, yes it could also give me about 128 fairly random bits...</li>
 *     <li>I don't have any real real numbers handy. I got floats and ints and arbitrary precision.</li>
 *     <li>A long represents a real number with (2<sup>64</sup>) valid representable states</li>
 *     <li>A double represents a real number with (2<sup>64</sup> - a couple) valid representable states</li>
 *     <li>So I will use a long, then, it's as real as a double and it also happens to have definitions of even and odd</li>
 *     <li>and it doesn't eat n < epsilon on addition either</li>
 *     <li>See length requirements... maybe we mean BigInteger</li>
 * </ul>
 * <pre>
 *
 * 2.     If the number is even, then divide by x=2.
 * </pre>
 * <ul>
 *     <li>This probably reduces randomness</li>
 *     <li>I may have a remainder, as x is not always equal to 2.</li>
 *     <li>I believe I could use that entropy, but I have no rule to use it with. I shall regretfully discard it.</li>
 * </ul>
 * <pre>
 *
 * 3.     If the number is odd, then add y=7.
 * </pre>
 * <ul>
 *     <li>This probably reduces randomness</li>
 *     <li>So aren't we glad we used a long> This 7 would disappear below epsilon in a large double</li>
 * </ul>
 * <pre>
 *
 * 4.     Check for longest palindromic sub-sequence.
 * </pre>
 * <ul>
 *     <li>And do nothing with the information, apparently. This is a delay step? A side-channel is desired?</li>
 * </ul>
 * <pre>
 *
 * 5.     At least z=5 rules should run.
 * </pre>
 * <ul>
 *     <li>okay... wait what? We only have at most 6 rules defined. Guess we'll stick them in an array.</li>
 *     <li>And if this is a member of said array, what does it do? Nothing, this is a meta-rule?</li>
 *     <li>This specifies a validation condition or silent input override - strength is "should"... let's override</li>
 * </ul>
 * <pre>
 *
 * 6.     At least half of numbers should be generated by lines # 2 and 3.
 * </pre>
 * <ul>
 *     <li>This rule also does not generate or affect a number.</li>
 *     <li>However, this affects the solution overall.</li>
 * </ul>
 *
 * And we are all out of salient problem statement.
 * Rules 1, 2, 3, and 4 are all direct rules which involve the number
 * Rules 5 and 6 are not.
 * Rule 5 would only apply if its term was at least 5? This seems excessively strange.
 * Rule 1 destroys the results of all rules, when it is run. It also includes the special wordings "start with",
 * and "the base".
 * Rule 4 doesn't appear to have any effect on the number, but affects the execution time. It is tempting to optimize it out.
 * So, rule 1 is not a member of the repeated set of rules, but counts as a rule when run, it runs first and once.
 * The repeated set consists of rules (2, 3, 4) at most.
 *
 * So, for example, with all parameters defaulted:
 * <ul>
 * <li>we'd have run 0 rules, until we start by running rule 1</li>
 * <li>we'd run rule 2, then rule 3, then rule 4, then rule 2.</li>
 * </ul>
 * Because z is never less than 5, rules 2 and 3 will always run for each number, and 2 will always run at least as many times
 * as rule 3. It appears far from trivial to determine how often they AFFECT a number, though.
 * It is unclear if rule 6 is considered to be in effect when z==5, which is probably the case where it is most in question.
 * If Rule 6 is in effect, we will need to maintain counters within rules 2 and 3 OR prove that either 2 or 3 will affect
 * a number more than half the time. Half or more of longs are even.
 * But hold on, z might in fact be less than 5. If rule 2 runs AT ALL, though, rule 6 is satisfied.
 * We also do not break the contract for Z by forcing it to 5 if it is less, since it only specifies a minimum.
 *
 * Note that the expectation that rule 1 will affect the outcome more than half the time is only statistically valid.
 * And, it doesn't hold well. So, we will bump the minimum z to 3 - without affecting our contract on z. It has still specified
 * a minimum.
 *
 * 3:41 with slight interruption, analysis of problem statement
 *
 * 3:50, interruptions becoming significant. It occurs that Rule 1 is loosely stated enough to allow for generating numbers
 * in a more convenient range, say, 30-40 decimal digits. This does not remove all padding and truncation concern
 *
 * 4:15 - hard break, as dinner is trying to be a thing right now
 *
 * So I came back around, 6:30 maybe? I remember noting that it was now slightly more than 4 hours absolute from seeing
 * the problem statement, but I have not been uninterrupted.
 *
 * It is now 8:43pm, so I am almost out of time even considering breaks. However, adding the controller and its tests is
 * pretty much algoristic.
 */
package net.zethmayr.benjamin.demo.koncertuuid;